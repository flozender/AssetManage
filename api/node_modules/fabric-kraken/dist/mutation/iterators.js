"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const validate_1 = require("./validate");
const deep_diff_1 = require("deep-diff");
// -------------- Implementation --------------
function toArray(iterator, qualifier) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = [];
        let current = yield iterator.next();
        if (current.value === undefined && current.done) {
            yield iterator.close();
            return results;
        }
        while (true) {
            let result;
            if ('key' in current.value) {
                result = yield convertStateQueryEntry(current, qualifier);
            }
            else if ('is_delete' in current.value) {
                result = yield convertHistoryQueryEntry(current);
            }
            else {
                throw new Error(`toArray only supports StateQueryIterators and HistoryQueryIterators`);
            }
            results.push(result);
            if (current.done)
                break;
            current = yield iterator.next();
        }
        yield iterator.close();
        return results;
    });
}
exports.toArray = toArray;
function convertStateQueryEntry(entry, validationType) {
    return __awaiter(this, void 0, void 0, function* () {
        if (entry.value && entry.value.value.toString()) {
            let value;
            try {
                value = JSON.parse(entry.value.value.toString('utf8'));
            }
            catch (err) {
                value = entry.value.value.toString('utf8');
            }
            return {
                key: entry.value.key,
                value: validationType
                    ? validate_1.mutateAndValidate(value, validationType)
                    : value
            };
        }
    });
}
function convertHistoryQueryEntry(current) {
    return __awaiter(this, void 0, void 0, function* () {
        const entry = current.value;
        try {
            entry.value = JSON.parse(entry.value.toString('utf8'));
        }
        catch (err) {
            entry.value = entry.value.toString('utf8');
        }
        const formattedTimestamp = new Date(0);
        formattedTimestamp.setUTCSeconds(entry.timestamp.getSeconds());
        entry.timestamp = formattedTimestamp;
        return entry;
    });
}
/**
 * Goes through a StateQueryIterator and converts all the elements it iterates over,
 * unbuffering the values and saving them into an Map with their original key, which it then returns.
 * @param iterator
 */
function toMap(iterator, qualifier) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = new Map();
        let current = yield iterator.next();
        if (Object.keys(current).length === 2 && current.done) {
            yield iterator.close();
            return results;
        }
        while (true) {
            let result;
            if ('key' in current.value) {
                result = yield convertStateQueryEntry(current, qualifier);
                results.set(result.key, result.value);
            }
            else if ('is_delete' in current.value) {
                result = yield convertHistoryQueryEntry(current);
                results.set(result.tx_id, result);
            }
            else {
                throw new Error(`toArray only supports StateQueryIterators and HistoryQueryIterators`);
            }
            if (current.done)
                break;
            current = yield iterator.next();
        }
        yield iterator.close();
        return results;
    });
}
exports.toMap = toMap;
function toDiff(keyModifications) {
    if (Array.isArray(keyModifications))
        return differenceFromArray(keyModifications);
    else if (keyModifications instanceof Map)
        return differenceFromMap(keyModifications);
}
exports.toDiff = toDiff;
function differenceFromArray(keyModifications) {
    const diffArray = [];
    let previousValue;
    for (const modification of keyModifications) {
        diffArray.push(formatKeyModification(previousValue, modification));
        previousValue = modification.value;
    }
    return diffArray;
}
function differenceFromMap(keyModifications) {
    const diffMap = new Map();
    let previousValue;
    keyModifications.forEach((modification, _) => {
        diffMap.set(modification.tx_id, formatKeyModification(previousValue, modification));
        previousValue = modification.is_delete ? undefined : modification.value;
    });
    return diffMap;
}
function formatKeyModification(oldVal, newMod) {
    // To translate the 'kind' into something more semantic
    const types = {
        N: 'CREATE',
        D: 'DELETE',
        E: 'UPDATE'
    };
    // Find the delta, if there isn't one then an empty array
    const newVal = newMod.is_delete ? undefined : newMod.value;
    let rawDiff = deep_diff_1.diff(oldVal, newVal);
    rawDiff = rawDiff ? rawDiff : [];
    // Filter out Array markers and modify field names
    const formattedDiffs = rawDiff
        .filter(difference => {
        return !(difference.kind === 'A');
    })
        .map(difference => {
        const formattedDiff = {
            type: types[difference.kind],
            path: difference.path
        };
        if ('lhs' in difference)
            formattedDiff.old = difference.lhs;
        if ('rhs' in difference)
            formattedDiff.new = difference.rhs;
        return formattedDiff;
    });
    // Put together the formatted modification
    const formattedKeyModification = {
        tx_id: newMod.tx_id,
        timestamp: newMod.timestamp,
        value: {
            old: oldVal,
            new: newVal,
            delta: formattedDiffs
        }
    };
    return formattedKeyModification;
}
//# sourceMappingURL=iterators.js.map