"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const class_validator_1 = require("class-validator");
const parse_1 = require("./parse");
const class_transformer_1 = require("class-transformer");
// ------------------------------------------------------------------------
// Error Report formatting
// ------------------------------------------------------------------------
/**
 * Format the validation errors returned by class-validator into an object with similar structure to
 * the desired object, highlighting the model violations so they can be easily addressed.
 * @param errors
 */
function formatErrors(errors) {
    const report = {};
    errors.map((error) => {
        if (error.constraints !== undefined) {
            report[error.property] = formatError(error);
        }
        if (error.children && error.children.length) {
            report[error.property] = {};
            report[error.property].children = formatErrors(error.children);
        }
    });
    return report;
}
/**
 * Format an individual validation error into a structure listing the invalid value and it's violations.
 * @param error
 */
function formatError(error) {
    const formattedError = {
        value: util_1.isUndefined(error.value) ? 'undefined' : error.value,
        violations: []
    };
    for (const key in error.constraints) {
        formattedError.violations.push(error.constraints[key]);
    }
    return formattedError;
}
// ------------------------------------------------------------------------
// Decorator
// ------------------------------------------------------------------------
const validatorOptions = {
    whitelist: true,
    forbidNonWhitelisted: true
};
/**
 * Arguemnts passed into fabric chaincode are in string format.
 *
 * Applying this decorator to a method will intercept the function before it is called and parse the stringified arguments
 * into the respective types passed into it.
 *
 * @param {any} types Constructors for types of the arguments at respective postitions.
 */
function mutateArgs(...types) {
    if (types.length === 0)
        throw new Error(`You must specify a type to validate against`);
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args) {
            const mutations = mutateAndValidate(args, types);
            args = Array.isArray(mutations) ? mutations : [mutations];
            return originalMethod.apply(this, args);
        };
        return descriptor;
    };
}
exports.mutateArgs = mutateArgs;
function mutateAndValidate(candidates, targetTypes) {
    const mutated = [];
    candidates = Array.isArray(candidates) ? candidates : [candidates];
    targetTypes = Array.isArray(targetTypes) ? targetTypes : [targetTypes];
    for (let i = 0; i < candidates.length; i++) {
        let currentArg = candidates[i];
        const currentTargetType = targetTypes[i];
        if (currentTargetType === undefined) {
            mutated.push(currentArg);
            continue;
        }
        if (currentTargetType.name === 'Date') {
            if (currentArg instanceof Date) {
                mutated.push(currentArg);
            }
            else if (typeof currentArg === 'string') {
                mutated.push(parse_1.stringToDate(currentArg));
            }
            else
                throw new Error(`You cannot mutate a '${currentArg.constructor.name}' into a 'Date'`);
            continue;
        }
        if (typeof currentArg === 'object') {
            currentArg = JSON.stringify(currentArg);
        }
        if (util_1.isString(currentArg) && currentTargetType.name !== 'String') {
            currentArg = parseString(currentArg);
        }
        if (util_1.isPrimitive(currentArg) &&
            !validPrimitiveMutation(currentArg, currentTargetType))
            throw new Error(`You cannot mutate a '${currentArg.constructor.name}' into a '${currentTargetType.name}'`);
        if (util_1.isArray(currentArg)) {
            const mutations = mutateAndValidate(currentArg, new Array(currentArg.length).fill(currentTargetType));
            util_1.isArray(mutations)
                ? mutated.push(...mutations)
                : mutated.push(currentArg);
            break;
        }
        if (currentArg.constructor.name === 'Object')
            currentArg = class_transformer_1.plainToClass(currentTargetType, currentArg);
        validateObject(currentArg);
        mutated.push(currentArg);
    }
    return mutated.length === 1 ? mutated[0] : mutated;
}
exports.mutateAndValidate = mutateAndValidate;
function validPrimitiveMutation(candidate, targetType) {
    return ((typeof candidate === 'string' && targetType.name === 'String') ||
        (typeof candidate === 'number' && targetType.name === 'Number') ||
        (typeof candidate === 'boolean' && targetType.name === 'Boolean'));
}
function validateObject(candidate) {
    const rawErrors = class_validator_1.validateSync(candidate, validatorOptions);
    if (rawErrors.length !== 0)
        throw new Error(JSON.stringify(formatErrors(rawErrors)));
}
function parseString(candidate) {
    try {
        return JSON.parse(candidate);
    }
    catch (error) {
        if (error.message.indexOf(`SyntaxError: Unexpected token ${candidate[0]} in JSON at position 0`) !== -1)
            throw error;
        return candidate;
    }
}
//# sourceMappingURL=validate.js.map