"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * PathTree is a tree structure where each node can contain a 'data' property which is a any object.
 */
class PathTree {
    /**
     * Initialise the tree, if no root node is provided, a blank tree is instantiated.
     * @param initialRoot
     */
    constructor(initialRoot) {
        if (initialRoot)
            this.root = initialRoot;
        else
            this.root = {};
    }
    /**
     * Creates a new node at the given path, creating intermediate nodes if they do not already exist.
     * @param path
     * @param newData
     */
    createNode(path, newData) {
        traverseToAndCreateNode(this.root, path, 0, newData);
    }
    /**
     * Retrieves the node at a given path.
     *
     * Errors if this node does not exist or the path terminates prematurely.
     * @param path
     */
    getNode(path) {
        return traverseToAndRetrieveNode(this.root, path, 0);
    }
    /**
     * Updates the node's data at the given path.
     *
     * Errors if the node nodes not exist or the path terminates prematurely.
     * @param path
     * @param newData
     */
    updateNode(path, newData) {
        const leaf = this.getNode(path);
        leaf.data = newData;
    }
    /**
     * Removes the node at the given path (and any children below).
     *
     * Errors if the node nodes not exist or the path terminates prematurely.
     * @param path
     */
    removeNode(path) {
        let nodeKey;
        let parentNode;
        switch (path.length) {
            case 0:
                throw new Error('You cannot remove the root node');
            case 1:
                nodeKey = path[0];
                if (nodeKey in this.root) {
                    delete this.root[nodeKey];
                }
                else {
                    throw new Error(`Path stops at ''`);
                }
                return;
            case 2:
                nodeKey = path[1];
                parentNode = this.getNode([path[0]]);
                if (nodeKey in parentNode) {
                    delete parentNode[nodeKey];
                }
                else {
                    throw new Error(`Path stops at '${path[0]}'`);
                }
                return;
            default:
                parentNode = this.getNode(path.slice(0, path.length - 1));
                nodeKey = path[path.length - 1];
                if (nodeKey in parentNode) {
                    delete parentNode[nodeKey];
                }
                else {
                    throw new Error(`Path stops at '${path
                        .slice(0, path.length - 1)
                        .join(' • ')}'`);
                }
                return;
        }
    }
}
exports.default = PathTree;
/**
 * [INTERNAL FUNCTION]
 *
 * Traverses the PathTree, creating nodes when required and populating intermediates with an undefined 'data' property and the leaf with the new data.
 *
 * @param currentNode
 * @param path
 * @param pathIndex
 * @param newData
 */
function traverseToAndCreateNode(currentNode, path, pathIndex, newData) {
    const nextKey = path[pathIndex];
    const endOfPath = pathIndex === path.length;
    const currentNodeDataUndefined = currentNode.data === undefined;
    const nextStepExists = nextKey in currentNode;
    if (endOfPath) {
        if (currentNodeDataUndefined) {
            currentNode.data = newData;
        }
        else {
            throw new Error(`Cannot add data to leaf at '${path.join(' • ')}', data exists already`);
        }
    }
    else {
        if (!nextStepExists) {
            currentNode[nextKey] = { data: undefined };
        }
        traverseToAndCreateNode(currentNode[nextKey], path, ++pathIndex, newData);
    }
}
/**
 * [INTERNAL FUNCTION]
 *
 * Traverses the PathTree, returning the node at the end of the path.
 *
 * Errors if the node does not exist or path ends prematurely.
 * @param currentNode
 * @param path
 * @param pathIndex
 */
function traverseToAndRetrieveNode(currentNode, path, pathIndex) {
    const nextKey = path[pathIndex];
    const endOfPath = pathIndex === path.length;
    const nextStepExists = nextKey in currentNode;
    if (endOfPath) {
        return currentNode;
    }
    else {
        if (!nextStepExists) {
            throw new Error(`Path stops at '${path.slice(0, pathIndex).join(' • ')}'`);
        }
        return traverseToAndRetrieveNode(currentNode[nextKey], path, ++pathIndex);
    }
}
//# sourceMappingURL=pathTree.js.map