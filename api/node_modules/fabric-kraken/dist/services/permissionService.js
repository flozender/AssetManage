"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ruleBook_1 = require("../permission/ruleBook");
const constants_1 = require("../common/constants");
const EMPTY_NAMESPACE = '';
/**
 * The Permissions Service maintains a hierarchical permission tree describing who is allowed to access the app, it's controllers and their methods.
 *
 * The hierchy of the tree acts as a collection of whitelists that filter the allowed groups at each stage. For a user to have permission to call a given
 * method they must be permitted at App, Controller and Method level.
 *
 * The Permissions Service is a singleton class that maintains global permissions for the app.
 */
class PermissionService {
    // ------------------------------------------------------------
    // Set
    // ------------------------------------------------------------
    /**
     * Sets groups who have permission to call methods on a specific contract.
     * @param classId
     * @param newRule
     */
    static setClassPermission(classId, newRule) {
        this.ruleBook.createRule([constants_1.CONTRACTS_PERMISSION_NAMESPACE, classId], newRule);
    }
    /**
     * Sets groups who have permission to call a specific method on a specific contract.
     * @param classId
     * @param methodId
     * @param newRule
     */
    static setMethodPermission(classId, methodId, newRule) {
        this.ruleBook.createRule([constants_1.CONTRACTS_PERMISSION_NAMESPACE, classId, methodId], newRule);
    }
    // ------------------------------------------------------------
    // Check
    // ------------------------------------------------------------
    /**
     * Checks if the supplied identity has permissions to call a specific method on a specific contract.
     * @param candidate
     * @param namespace Permission namespace, set this to 'app'
     * @param controller
     * @param methodName
     */
    static hasPermission(ctx, className, methodName) {
        return (hasClassPermissions(ctx, this.ruleBook, className) &&
            hasMethodPermissions(ctx, this.ruleBook, className, methodName));
    }
}
PermissionService.ruleBook = new ruleBook_1.default();
exports.default = PermissionService;
//////////////////////////////////////////////////////////////////////////////
// Utility Functions
//////////////////////////////////////////////////////////////////////////////
/**
 *
 * @param newRule
 */
function permissions(newRule) {
    return (...args) => {
        if (args.length === 1) {
            const constructor = args[0];
            PermissionService.setClassPermission(constructor.name, newRule);
            return constructor;
        }
        else if (args.length === 3) {
            const classPrototype = args[0];
            const className = classPrototype.constructor.name;
            const methodName = args[1];
            const propertyDescriptor = args[2];
            PermissionService.setMethodPermission(className, methodName, newRule);
            return propertyDescriptor;
        }
        throw new Error('You can only add the @permissions decorator to Classes and Class methods');
    };
}
exports.permissions = permissions;
/**
 * [INTERNAL FUNCTION]
 *
 * Returns true if the identifier is in the controller rules or the controller rules are undefined.
 *
 * @param ruleBook
 * @param identifier
 * @param className
 */
function hasClassPermissions(ctx, ruleBook, className) {
    let rule;
    try {
        rule = ruleBook.getRule([constants_1.CONTRACTS_PERMISSION_NAMESPACE, className]);
    }
    catch (error) {
        if (error.message === `Path stops at '${EMPTY_NAMESPACE}'` ||
            error.message ===
                `Path stops at '${constants_1.CONTRACTS_PERMISSION_NAMESPACE}'`)
            rule = undefined;
        else
            throw error;
    }
    return rule === undefined || rule(ctx);
}
/**
 * [INTERNAL FUNCTION]
 *
 * Returns true if the identifier is in the method rules or the method rules are undefined.
 *
 * @param ruleBook
 * @param identifier
 * @param className
 * @param methodId
 */
function hasMethodPermissions(ctx, ruleBook, className, methodId) {
    let rule;
    try {
        rule = ruleBook.getRule([
            constants_1.CONTRACTS_PERMISSION_NAMESPACE,
            className,
            methodId
        ]);
    }
    catch (error) {
        if (error.message === `Path stops at '${EMPTY_NAMESPACE}'` ||
            error.message ===
                `Path stops at '${constants_1.CONTRACTS_PERMISSION_NAMESPACE}'` ||
            error.message ===
                `Path stops at '${constants_1.CONTRACTS_PERMISSION_NAMESPACE} â€¢ ${className}'`)
            rule = undefined;
        else
            throw error;
    }
    return rule === undefined || rule(ctx);
}
//# sourceMappingURL=permissionService.js.map