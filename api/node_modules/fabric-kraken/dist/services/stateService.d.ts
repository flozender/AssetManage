import { ChaincodeStub, Iterators } from 'fabric-shim';
import { ClassType } from 'class-transformer/ClassTransformer';
export interface PaginationMetadata {
    fetched_records_count: number;
    bookmark: string;
}
export default class StateService {
    private stub;
    constructor(stub: ChaincodeStub);
    /**
     * Returns the value to which the specified key is mapped in state, throwing an error if it does not exist.
     * The returned value's schema is then optionally validated against a given Class.
     * @param key Simple/Composite key of the data in state.
     * @param options
     */
    get<T>(key: string | string[], options?: {
        /** lbah */
        validateAs?: ClassType<T>;
    }): Promise<T>;
    /**
     * Maps the specified value with the specified key in state.
     * Optionally checks if the specified key is already mapped and errors if so.
     * @param key Simple/Composite key to map data to.
     * @param value Data to placed in state.
     * @param doNotOverwrite Throws an error if data already exists at the given key [Optional].
     */
    put(key: string | string[], value: any, options?: {
        doNotOverwrite?: boolean;
    }): Promise<void>;
    /**
     * Deletes the mapping for a key state if it is present in state,
     * only if the retrieved value is of the expected class type
     * @param {string | string[]} key Simple/Composite key to delete
     * @param {ClassType} validateAs Class to validate returned value's schema against. Errors if data is not an object  [Optional].
     */
    delete<T>(key: string | string[], options?: {
        validateAs?: ClassType<T>;
    }): Promise<void>;
    /**
     * Returns true if state contains a mapping for the specified key.
     * @param {string | string[]} key Simple/Composite Key to check.
     */
    keyExists(key: string | string[]): Promise<boolean>;
    getRange<T>(startKey: string[], endKey: string[], options?: {
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Iterators.StateQueryIterator;
        metadata: PaginationMetadata;
    }>;
    getRange<T>(startKey: string[], endKey: string[], options?: {
        returnAs?: MapConstructor;
        validateAs?: ClassType<T>;
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Map<string, T>;
        metadata: PaginationMetadata;
    }>;
    getRange<T>(startKey: string[], endKey: string[], options?: {
        returnAs?: ArrayConstructor;
        validateAs?: ClassType<T>;
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: T[];
        metadata: PaginationMetadata;
    }>;
    getRange<T>(startKey: string, endKey: string, options?: {
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Iterators.StateQueryIterator;
        metadata: PaginationMetadata;
    }>;
    getRange<T>(startKey: string, endKey: string, options?: {
        returnAs?: MapConstructor;
        validateAs?: ClassType<T>;
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Map<string, T>;
        metadata: PaginationMetadata;
    }>;
    getRange<T>(startKey: string, endKey: string, options?: {
        returnAs?: ArrayConstructor;
        validateAs?: ClassType<T>;
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: T[];
        metadata: PaginationMetadata;
    }>;
    getPartial(partialKey: string[], options?: {
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Iterators.StateQueryIterator;
        metadata?: PaginationMetadata;
    }>;
    getPartial<T>(partialKey: string[], options?: {
        returnAs?: MapConstructor;
        validateAs?: ClassType<T>;
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Map<string, T>;
        metadata?: PaginationMetadata;
    }>;
    getPartial<T>(partialKey: string[], options?: {
        returnAs?: ArrayConstructor;
        validateAs?: ClassType<T>;
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Array<{
            key: string;
            value: T | T[];
        }>;
        metadata?: PaginationMetadata;
    }>;
    /**
     * Returns the the values that match the CouchDB selector provided.
     *
     * This function only works on peers utilising a CouchDB database to maintain state.
     */
    query(selector: object, options?: {
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Iterators.StateQueryIterator;
        metadata?: PaginationMetadata;
    }>;
    query<T>(selector: object, options?: {
        returnAs?: MapConstructor;
        validateAs?: ClassType<T>;
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: Map<string, T>;
        metadata?: PaginationMetadata;
    }>;
    query<T>(selector: object, options?: {
        returnAs?: ArrayConstructor;
        validateAs?: ClassType<T>;
        pageSize?: number;
        bookmark?: string;
    }): Promise<{
        result: T[];
        metadata?: PaginationMetadata;
    }>;
    /**
     * WARNING: HERE BE DRAGONS.
     *
     * This is a first-pass naive implementation currently under testing.
     * We do not recommend using this function yet.
     */
    flush(): Promise<void>;
    getHistory(key: string | string[]): Promise<Iterators.HistoryQueryIterator>;
    getHistory(key: string | string[], options?: {
        returnAs: MapConstructor;
        asDifference?: boolean;
    }): Promise<Map<string, Iterators.KeyModification>>;
    getHistory(key: string | string[], options?: {
        returnAs: ArrayConstructor;
        asDifference?: boolean;
    }): Promise<Iterators.KeyModification[]>;
}
