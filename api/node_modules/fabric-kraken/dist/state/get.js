"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffers_1 = require("../mutation/buffers");
// ##############################################################################
// Primitive Gets
// ##############################################################################
/**
 * Gets the value stored with the given key
 *
 * @param {ChaincodeStub} stub
 * @param {string} key
 */
function get(stub, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const resultAsBuffer = yield stub.getState(key);
        if (resultAsBuffer === undefined || resultAsBuffer.byteLength === 0)
            throw new Error(`Invalid key '${key}'`);
        return buffers_1.fromBuffer(resultAsBuffer);
    });
}
exports.get = get;
/**
 * Gets the value stored with the given composite key
 *
 * @param {ChaincodeStub} stub
 * @param {string[]} key
 */
function getComposite(stub, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const root = key[0];
        const suffixes = key.slice(1);
        const compKey = stub.createCompositeKey(root, suffixes);
        return get(stub, compKey);
    });
}
exports.getComposite = getComposite;
// ##############################################################################
// Ranged Gets
// ##############################################################################
/**
 * Gets all values for keys between the startKey and endKey.
 *
 * Works with keys made of Strings and stringified Numbers and Dates.
 * @param {ChaincodeStub} stub
 * @param {string} startKey
 * @param {string} endKey
 */
function getRange(stub, startKey, endKey) {
    return __awaiter(this, void 0, void 0, function* () {
        return stub.getStateByRange(startKey, endKey);
    });
}
exports.getRange = getRange;
/**
 * Gets all values for composite keys ending with middleSuffixes
 * between the startSuffix and endSuffix (inclusive/exclusive).
 *
 * Works with keys made of Strings and stringified Numbers / ISO Dates.
 * @param {ChaincodeStub} stub
 * @param {string[]} startKey
 * @param {string[]} endKey
 */
function getRangeComposite(stub, startKey, endKey) {
    return __awaiter(this, void 0, void 0, function* () {
        const startRoot = startKey[0];
        const startSuffixes = startKey.slice(1);
        const startCompKey = stub.createCompositeKey(startRoot, startSuffixes);
        const endRoot = endKey[0];
        const endSuffixes = endKey.slice(1);
        const endCompKey = stub.createCompositeKey(endRoot, endSuffixes);
        return getRange(stub, startCompKey, endCompKey);
    });
}
exports.getRangeComposite = getRangeComposite;
function getRangePaginated(stub, startKey, endKey, pageSize, bookmark) {
    return __awaiter(this, void 0, void 0, function* () {
        return stub.getStateByRangeWithPagination(startKey, endKey, pageSize, bookmark);
    });
}
exports.getRangePaginated = getRangePaginated;
function getRangeCompositePaginated(stub, startKey, endKey, pageSize, bookmark) {
    return __awaiter(this, void 0, void 0, function* () {
        const startRoot = startKey[0];
        const startSuffixes = startKey.slice(1);
        const startCompKey = stub.createCompositeKey(startRoot, startSuffixes);
        const endRoot = endKey[0];
        const endSuffixes = endKey.slice(1);
        const endCompKey = stub.createCompositeKey(endRoot, endSuffixes);
        return getRangePaginated(stub, startCompKey, endCompKey, pageSize, bookmark);
    });
}
exports.getRangeCompositePaginated = getRangeCompositePaginated;
// ##############################################################################
// Partial Gets
// ##############################################################################
/**
 * Gets all values for composite keys where *root* and *key[]* form the start of the key.
 *
 * @param {ChaincodeStub} stub
 * @param {string[]} key
 */
function getPartialComposite(stub, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const root = key[0];
        const suffixes = key.slice(1);
        return stub.getStateByPartialCompositeKey(root, suffixes);
    });
}
exports.getPartialComposite = getPartialComposite;
function getPartialCompositePaginated(stub, key, pageSize, bookmark) {
    return __awaiter(this, void 0, void 0, function* () {
        const root = key[0];
        const suffixes = key.slice(1);
        return stub.getStateByPartialCompositeKeyWithPagination(root, suffixes, pageSize, bookmark);
    });
}
exports.getPartialCompositePaginated = getPartialCompositePaginated;
// ##############################################################################
// History Gets
// ##############################################################################
/**
 * Gets the history of a given key
 *
 * @param {ChaincodeStub} stub
 * @param {string} key
 */
function getHistory(stub, key) {
    return __awaiter(this, void 0, void 0, function* () {
        return stub.getHistoryForKey(key);
    });
}
exports.getHistory = getHistory;
/**
 * Gets the history of a given key
 *
 * @param {ChaincodeStub} stub
 * @param {string[]} key
 */
function getHistoryComposite(stub, key) {
    return __awaiter(this, void 0, void 0, function* () {
        const root = key[0];
        const suffixes = key.slice(1);
        const compKey = stub.createCompositeKey(root, suffixes);
        return getHistory(stub, compKey);
    });
}
exports.getHistoryComposite = getHistoryComposite;
//# sourceMappingURL=get.js.map