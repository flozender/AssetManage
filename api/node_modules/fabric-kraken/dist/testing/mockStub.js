"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fabric_mock_stub_1 = require("@theledger/fabric-mock-stub");
const utils_1 = require("./utils");
const mockState_1 = require("./mockState");
const buffers_1 = require("../mutation/buffers");
/**
 * Improved version of the wearetheledger ChaincodeMockStub with helper functions to set up and retrieve from state.
 */
class KrakenMockStub extends fabric_mock_stub_1.ChaincodeMockStub {
    constructor(chaincode) {
        const stubName = utils_1.randomText();
        super(stubName, chaincode);
        this.state = new mockState_1.default();
    }
    /**
     * Generates a certificate with the supplied userId and sets the stub to use it
     * along with the mspId supplied.
     * @param stub
     * @param userId
     * @param mspId
     */
    _setUserId(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            const certCreationResult = yield utils_1.makeCert(userId);
            this.usercert = certCreationResult.certificate;
        });
    }
    _setMspId(mspId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (mspId)
                this.setCreator(mspId);
        });
    }
    /**
     * Sets the args for the current transaction context.
     * @param stub
     * @param args
     */
    _setArgs(...args) {
        this.args = args;
    }
    /**
     * Loads the provided data into the mocked state
     * @param newState Array of MockStatePair objects describing the KV pairs to place in state
     * @param deleteHistory remove old key and leave no trace in history before new key is inserted (defaults to true)
     * @param txId transaction ID that can be used to identify this method's effects in history
     */
    _setState(newState, deleteHistory = true, txId) {
        return __awaiter(this, void 0, void 0, function* () {
            newState = Array.isArray(newState) ? newState : [newState];
            for (const statePair of newState) {
                if (deleteHistory)
                    yield this._clearState(statePair, true);
                const transactionID = txId ? txId : utils_1.randomText();
                this.mockTransactionStart(transactionID);
                yield this.putState(utils_1.makeKey(statePair.key), buffers_1.toBuffer(statePair.value));
                this.mockTransactionEnd(transactionID);
            }
        });
    }
    /**
     * Remove a key from state
     * @param key key of pair to remove
     * @param deleteHistory remove key and leave no trace in history (defaults to true)
     */
    _clearState(stateToClear, deleteHistory = true, txId) {
        return __awaiter(this, void 0, void 0, function* () {
            stateToClear = Array.isArray(stateToClear)
                ? stateToClear
                : [stateToClear];
            txId = txId ? txId : utils_1.randomText();
            this.mockTransactionStart(txId);
            for (const statePair of stateToClear) {
                const bakedKey = utils_1.makeKey(statePair.key);
                if (deleteHistory) {
                    this.state[bakedKey] = undefined;
                    this.history[bakedKey] = undefined;
                }
                else {
                    yield this.deleteState(bakedKey);
                }
            }
            this.mockTransactionEnd(txId);
        });
    }
}
exports.default = KrakenMockStub;
//# sourceMappingURL=mockStub.js.map