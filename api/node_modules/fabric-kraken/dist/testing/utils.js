"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fabric_mock_stub_1 = require("@theledger/fabric-mock-stub");
const util_1 = require("util");
const pem_1 = require("pem");
/**
 * Generates a string of random letters. Useful for generating throwaway IDs.
 */
function randomText() {
    return Math.random()
        .toString(36)
        .substring(7);
}
exports.randomText = randomText;
/**
 * Creates either a simple or composite key depending on whether string or array of strings is supplied.
 *
 * @param {string | string[]}key
 */
function makeKey(key) {
    if (util_1.isArray(key)) {
        // Clone key so we don't modify the object being passed in
        const keyCopy = JSON.parse(JSON.stringify(key));
        // Extract root
        const root = keyCopy.splice(0, 1)[0];
        const stub = new fabric_mock_stub_1.ChaincodeMockStub('key', null);
        try {
            return stub.createCompositeKey(root, keyCopy);
        }
        catch (error) {
            if (error.message ===
                'object type or attribute not a non-zero length string')
                throw new Error(`Keys can only be created from strings, ${JSON.stringify(key)} contains a non-string`);
            else
                throw error;
        }
    }
    else {
        if (typeof key !== 'string')
            throw new Error(`Keys can only be created from strings, '${key}' is a ${typeof key}`);
        return key;
    }
}
exports.makeKey = makeKey;
/**
 * Breaks a composite key into an array of it's constituent keys, leaves a simple key untouched.
 * @param key
 */
function unmakeKey(key) {
    if (key.indexOf('\u0000') === -1)
        return key;
    else {
        const stub = new fabric_mock_stub_1.ChaincodeMockStub('key', null);
        const split = stub.splitCompositeKey(key);
        return [split.objectType, ...split.attributes];
    }
}
exports.unmakeKey = unmakeKey;
/**
 * Creates a certificate bearing the supplied common name.
 *
 * @param commonName
 */
function makeCert(commonName) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            pem_1.createCSR({
                commonName
            }, (csrErr, result) => {
                if (csrErr)
                    reject(csrErr);
                pem_1.createCertificate({
                    days: 1,
                    selfSigned: true,
                    csr: result.csr,
                    clientKey: result.clientKey
                }, (certErr, keys) => {
                    if (certErr)
                        reject(certErr);
                    resolve(keys);
                });
            });
        });
    });
}
exports.makeCert = makeCert;
/**
 * Invoke a method on a given Contract.
 */
// tslint:disable-next-line:ban-types
function mockInvoke(contract, method, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const txId = (options && options.txId) || randomText();
        const ctx = options.ctx;
        const beforeTransaction = options.beforeTransaction === undefined
            ? true
            : options.beforeTransaction;
        const afterTransaction = options.afterTransaction === undefined
            ? false
            : options.afterTransaction;
        // We need to add the `contract:method` argument to the stub args so that beforeTransaction can see it
        let rawMethodArgs = ctx.stub.getArgs();
        const contractMethodId = `${contract.getName()}:${method}`;
        if (ctx.stub.getArgs() !== undefined) {
            ctx.stub.args = [contractMethodId, ...rawMethodArgs];
        }
        else {
            ctx.stub.args = [contractMethodId];
            rawMethodArgs = [];
        }
        // However, this isn't what is passed into the actual contract method call so we need to remove it for that
        ctx.stub.mockTransactionStart(txId);
        // tslint:disable-next-line:no-unused-expression
        beforeTransaction && (yield contract.beforeTransaction(ctx));
        const rawResult = yield contract[method](ctx, ...rawMethodArgs);
        const result = afterTransaction && (yield contract.afterTransaction(ctx, rawResult));
        ctx.stub.mockTransactionEnd(txId);
        return afterTransaction ? result : rawResult;
    });
}
exports.mockInvoke = mockInvoke;
//# sourceMappingURL=utils.js.map